# x86_64 System Calls

On x86_64, system calls are performed using the `syscall` instruction. The system call number is
passed in the `rax` register, and the arguments are passed to `rdi`, `rsi` and `rdx`.

The return value is stored in `rax`.

| Mnemonic                  | `rax` | `rdi`    | `rsi` | `rdx` |
| ------------------------- | ----- | -------- | ----- | ----- |
| [terminate](#terminate)   | 0     | process  |       |       |
| [get_memory](#get_memory) | 1     | segments | count |       |
| [map_memory](#map_memory) | 2     | entries  | count |       |

## Type Definitions

```c
typedef uint64_t SysResult;
typedef uint64_t ProcessHandle;
```

## terminate

```c
void terminate(ProcessHandle process);
```

The `Terminate` system call terminates the specified process.

If the provided parameter is `0`, the current process is terminated and the system call never
returns control to the caller.

### Returns

This system call always returns `0` on success, or never if the specified process is the current
one.

## get_memory

```c
typedef struct {
    start: uint64_t;
    size: uint64_t;
} Segment;

SysResult get_memory(Segment *segments, size_t count);
```

The `GetMemory` system call is used to retrieve the memory segments currently available on the
system.

`count` is the number of `Segment` structures that can be stored in the buffer referenced by
`segments`.

The kernel will write at most `count` instances of `Segment` to the buffer referenced by `segments`.

Those segments are guarenteed to be non-overlapping, and sorted by ascending order of their
addresses.

### Returns

This system call always succeeds and returns the number of segments available on the system.

Note that this _does not_ depend on the provided `count` value. This system call will always write
at most `count` elements to the `segments` buffer.

### Errors

- `INVALID_ARGUMENT` is returned if an invalid argument is found. Specifically, `segments` must
  be a valid pointer to a userspace buffer (unless count is `0`, in which case `segments` won't
  be accessed at all).

## map_memory

```c
typedef struct {
    uint64_t physical_address;
    uint64_t position;
} PageTableEntry;

SysResult map_memory(PageTableEntry const *entries, size_t count);
```

The `MapMemory` system call is used to insert a page table entry into the current process's
page table.

This system call can be used to map more physical memory into the current process's address space.

The `physical_address` of each entry is the _physical address_ of the page to be inserted into the
page table.

The `position` in each entry describes where to insert the page table entry in the page table. The
index is derived the same way virtual addresses are.

```txt
 - bit 0  - 12 : unused
 - bit 12 - 21 : l1 entry index
 - bit 21 - 30 : l2 entry index
 - bit 30 - 39 : l3 entry index
 - bit 39 - 48 : l4 entry index
 - bit 48 - 57 : l5 entry index (if supported)
```

### Errors

- `CONFLICT` is returned if one of the mappings proposed by the caller conflicts with the mapping
  of another process.

- `INVALID_ARGUMENT` is a an invalid value is found.
  - Specifically, it is only possible to map memory present in the segments returned by the
    `get_memory` system call.
  - The physical addresses must be page-aligned, and the position must be a valid position in the
    page table.
