# x86_64 System Calls

On x86_64, system calls are performed using the `syscall` instruction. The system call number is
passed in the `rax` register, and the arguments are passed to `rdi`, `rsi` and `rdx`.

The return value is stored in `rax`.

| Mnemonic                  | `rax` | `rdi`    | `rsi` | `rdx` |
| ------------------------- | ----- | -------- | ----- | ----- |
| [ring0](#ring0)           | 0     | data     | f     |       |
| [terminate](#terminate)   | 1     | process  |       |       |
| [get_memory](#get_memory) | 2     | segments | size  |       |
| [map_memory](#map_memory) | 3     | entries  | count |       |

## Type Definitions

```c
typedef uint64_t SysResult;
typedef uint64_t ProcessHandle;
```

## ring0

```c
SysResult ring0(void *data, void (*f)(void *data));
```

The `ring0` system call is used to execute a function in ring 0.

The provided `data` parameter is passed to `f` as its unique argument. The provided function is
guarenteed to be executed at most once.

Note that none of the parameters of this system call are validated by the kernel. Specifically, `f`
can point to any address and the kernel will still attempt to execute it.

### Returns

This function always return `0` on success.

## terminate

```c
SysResult terminate(ProcessHandle process);
```

The `terminate` system call terminates the specified process.

If the provided parameter is `0`, the current process is terminated and the system call never
returns control to the caller.

### Returns

This system call always returns `0` on success, or never if the specified process is the current
one.

## get_memory

```c
typedef struct {
    address: uint64_t;
    length: uint64_t;
} Segment;

SysResult get_memory(Segment *segments, size_t size);
```

The `get_memory` system call is used to retrieve the memory segments currently available on the
system.

`size` is the number of `Segment` structures that can be stored in the buffer referenced by
`segments`.

The kernel will write at most `size` instances of `Segment` to the buffer referenced by `segments`.

Those segments are guarenteed to be non-overlapping, sorted by ascending order of their
addresses, and their address and length to be page aligned.

### Returns

This system call always succeeds and returns the number of segments available on the system.

Note that this _does not_ depend on the provided `size` value. This system call will always write
at most `size` elements to the `segments` buffer.

### Errors

- `INVALID_ARGUMENT` is returned if an invalid argument is found. Specifically, `segments` must
  be a valid pointer to a userspace buffer (unless `size` is `0`, in which case `segments` won't
  be accessed at all).

## map_memory

```c
typedef struct {
    uint64_t physical_address;
    uint64_t position;
} PageTableEntry;

SysResult map_memory(PageTableEntry const *entries, size_t count);
```

The `map_memory` system call is used to insert a page table entry into the current process's
page table.

This system call can be used to map more physical memory into the current process's address space.

The `physical_address` of each entry is the _physical address_ of the page to be inserted into the
page table.

The `position` in each entry describes where to insert the page table entry in the page table. The
index is derived the same way virtual addresses are.

```txt
 - bit 0  - 12 : unused
 - bit 12 - 21 : l1 entry index
 - bit 21 - 30 : l2 entry index
 - bit 30 - 39 : l3 entry index
 - bit 39 - 48 : l4 entry index
 - bit 48 - 57 : l5 entry index (if supported)
```

### Errors

- `CONFLICT` is returned if one of the mappings proposed by the caller conflicts with the mapping
  of another process.

- `INVALID_ARGUMENT` is a an invalid value is found.
  - Specifically, it is only possible to map memory present in the segments returned by the
    `get_memory` system call.
  - The physical addresses must be page-aligned, and the position must be a valid position in the
    page table.
